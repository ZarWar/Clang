#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>

#define STATUS_400 "сервер обнаружил в запросе клиента синтаксическую ошибку. Появился в HTTP/1.0."
#define STATUS_401 "для доступа к запрашиваемому ресурсу требуется аутентификация. В заголовке ответ должен содержать поле WWW-Authenticate с перечнем условий аутентификации. Иными словами, для доступа к запрашиваемому ресурсу клиент должен представиться, послав запрос, включив при этом в заголовок сообщения поле Authorization с требуемыми для аутентификации данными. Если запрос уже включает данные для авторизации, ответ 401 означает, что в авторизации с ними отказано."
#define STATUS_402 "сервер обнаружил в запросе клиента синтаксическую ошибку. Появился в HTTP/1.0."
#define STATUS_403 "сервер понял запрос, но он отказывается его выполнять из-за ограничений в доступе для клиента к указанному ресурсу. Иными словами, клиент не уполномочен совершать операции с запрошенным ресурсом. Если для доступа к ресурсу требуется аутентификация средствами HTTP, то сервер вернёт ответ 401, или 407 при использовании прокси. В противном случае ограничения были заданы администратором сервера или разработчиком веб-приложения и могут быть любыми в зависимости от возможностей используемого программного обеспечения. В любом случае серверу следует сообщить причины отказа в обработке запроса. Наиболее вероятными причинами ограничения может послужить попытка доступа к системным ресурсам веб-сервера (например, файлам .htaccess или .htpasswd) или к файлам, доступ к которым был закрыт с помощью конфигурационных файлов, требование аутентификации не средствами HTTP, например, для доступа к системе управления содержимым или разделу для зарегистрированных пользователей либо сервер не удовлетворён IP-адресом клиента, например, при блокировках. Появился в HTTP/1.0."
#define STATUS_404 "самая распространённая ошибка при пользовании Интернетом, основная причина — ошибка в написании адреса Web-страницы. Сервер понял запрос, но не нашёл соответствующего ресурса по указанному URL. Если серверу известно, что по этому адресу был документ, то ему желательно использовать код 410. Ответ 404 может использоваться вместо 403, если требуется тщательно скрыть от посторонних глаз определённые ресурсы. Появился в HTTP/1.0."
#define STATUS_405 "указанный клиентом метод нельзя применить к текущему ресурсу. В ответе сервер должен указать доступные методы в заголовке Allow, разделив их запятой. Эту ошибку сервер должен возвращать, если метод ему известен, но он не применим именно к указанному в запросе ресурсу, если же указанный метод не применим на всём сервере, то клиенту нужно вернуть код 501 (Not Implemented). Появился в HTTP/1.1."
#define STATUS_406 "запрошенный URI не может удовлетворить переданным в заголовке характеристикам. Если метод был не HEAD, то сервер должен вернуть список допустимых характеристик для данного ресурса. Появился в HTTP/1.1."
#define STATUS_407 "ответ аналогичен коду 401 за исключением того, что аутентификация производится для прокси-сервера. Механизм аналогичен идентификации на исходном сервере. Появился в HTTP/1.1."
#define STATUS_408 "время ожидания сервером передачи от клиента истекло. Клиент может повторить аналогичный предыдущему запрос в любое время. Например, такая ситуация может возникнуть при загрузке на сервер объёмного файла методом POST или PUT. В какой-то момент передачи источник данных перестал отвечать, например, из-за повреждения компакт-диска или потери связи с другим компьютером в локальной сети. Пока клиент ничего не передаёт, ожидая от него ответа, соединение с сервером держится. Через некоторое время сервер может закрыть соединение со своей стороны, чтобы дать возможность другим клиентам сделать запрос. Этот ответ не возвращается, когда клиент принудительно остановил передачу по команде пользователя или соединение прервалось по каким-то иным причинам, так как ответ уже послать невозможно. Появился в HTTP/1.1."
#define STATUS_409 "запрос не может быть выполнен из-за конфликтного обращения к ресурсу. Такое возможно, например, когда два клиента пытаются изменить ресурс с помощью метода PUT. Появился в HTTP/1.1."
#define STATUS_410 "такой ответ сервер посылает, если ресурс раньше был по указанному URL, но был удалён и теперь недоступен. Серверу в этом случае неизвестно и местоположение альтернативного документа (например копии). Появился в HTTP/1.1."
#define STATUS_411 "для указанного ресурса клиент должен указать Content-Length в заголовке запроса. Без указания этого поля не стоит делать повторную попытку запроса к серверу по данному URI. Такой ответ естественен для запросов типа POST и PUT. Например, если по указанному URI производится загрузка файлов, а на сервере стоит ограничение на их объём. Тогда разумней будет проверить в самом начале заголовок Content-Length и сразу отказать в загрузке, чем провоцировать бессмысленную нагрузку, разрывая соединение, когда клиент действительно пришлёт слишком объёмное сообщение. Появился в HTTP/1.1."
#define STATUS_412 "возвращается, если ни одно из условных полей заголовка (If-Match и др., см. RFC 7232) запроса не было выполнено. Появился в HTTP/1.1."
#define STATUS_413 "возвращается в случае, если сервер отказывается обработать запрос по причине слишком большого размера тела запроса. Сервер может закрыть соединение, чтобы прекратить дальнейшую передачу запроса. Если проблема временная, то рекомендуется в ответ сервера включить заголовок Retry-After с указанием времени, по истечении которого можно повторить аналогичный запрос. Появился в HTTP/1.1. Ранее назывался «Request Entity Too Large»."

char answer[30] = "\0";
int  check = 0;
int  questionNumber = 0;
int  u = 0;
int  i;
char c;
char b;

char* typeYourAnswer (char* answer);
void checkAnswer (char* answer, char status);

int main() {

    while (true) {

        switch (questionNumber) {
            case 0:
                *answer = typeYourAnswer(answer);
                checkAnswer(answer, STATUS_400);

            default:
                questionNumber = 0;

        }
    }
}

char* typeYourAnswer (char* answer) {

    printf("Please, type your answer: ");

    i = 0;
    while( (c = getchar()) != '\n' && c != EOF ) {
        answer[i++] = c;
    }
    printf("answer = '%s'\n", answer);

    return *answer;

}

void checkAnswer (char* answer, char status) {

    while ((strcmp(answer, "Bad Request") != 0)) {

        for (int j = 0; j < 30; j++) {
            answer[j] = '\0';
        }


        if (check == 0) {
            sleep(1);
            printf("Wrong. Retry? y/n: ");
        } else {
            check = 0;
        }

        b = getchar();

        if (b  == 'y') {
            fflush(stdin);
            sleep(1);
            printf("\n");
            break;
        } else if (b == 'n') {
            fflush(stdin);
            sleep(1);
            break;
        } else {
            check = 1;
            fflush(stdin);
            sleep(1);
            printf("Please, input only 'y' or 'n': ");
            continue;
        }
    }


    // выводим правильный ответ

    if ((strcmp(answer, "Bad Request") == 0)) {
        sleep(1);
        printf("\nYour were right! The description is:\n%s\n\n", status);
        sleep(1);
    }

}
