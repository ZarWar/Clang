Всякий раз, когда я печатаю "пробел", мне нужно подсчитывать их количество. Как-будто я вношу эти пробелы в какой-то массив, чтобы в итоге после серии пробелов, когда пойдёт другой символ, я достал один пробел из загашника, и поставил его перед "не пробелом".

countingCSTNW.c
Всякий раз, когда я печатаю не пробел, не табуляцию, и не новую строку, я как-бы вношу символы в массив, и STATE = IN. И когда добавление символов в массив прекращается, STATE = OUT, ++nw.

digitVerticalHistogram.c
Мне нужен вывод количества каждой переменной в массиве в виде "столбов". Для этого мне нужно, скорее всего, запустить цикл, соответствующий количеству переменных в массиве, и внутри этого цикла запустить другой цикл, который будет проходить значение переменной как массив, и печатать "|" за каждую "целочисленную единицу" переменной. То-есть, если переменная равна шести, то цикл будет печатать шесть раз "столб".

digitHorizontalHistogram.c
Плясать нужно от переменной, которая будет определять высоту вертикальной гистограммы по наибольшему значению внутри массива "введённых чисел".

removeSpaces.c
Мне нужно считать каждый символ "новой строки". Если их больше одного подряд, все последующие символы удаляются.

entab.c
Нужно отделить "Putchar" так, чтобы он срабатывал при одиночных пробелах. Но когда их набегает больше трёх, печаталась табуляция, и пробелы не печатались.

removeEmptyLines.c
Нужно удалять пустые строки, даже если в них есть пробелы и табуляции после символа "\n". Если я буду считать количество пробелов, то нужно считать и количество букв перед следующим символом "новой строки". Иначе может возникнуть ситуация, когда строка удалится просто потому что перед "\n" есть один или более пробелов.

polishCalc.c =================================================================================
Чтобы добавить возможность работы с переменными нужно два массива, символьный и целочисленный.

После символа ‘=’ внутри Getop() нужно воткнуть функции на считывание цифр, пушинье их в отдельный массив, и по итогу математически обработать их отдельной функцией со свитчём как в main()

У тебя же Getop() работает в main(), в него и возвращает результаты своей деятельности. Нужно подумать, как теперь с этим жить.

Погоди, так ты можешь внутри новых функций в Getop() не возвращать данные в main(), а отправлять их во внешний массив. Да и вообще делать что угодно, а main() об этом и не узнает.

Нужно уловие считывания буквы, потом условие что сразу за буквой идёт '=', потом только условие что все символы это цифры, которые начинают забиваться с нулевого индекса в массив, откуда они заберутся и станут одной цифрой. На данный момент хер знает куда эту цифру девать. Главное условие - на пробелы  не обращать внимание, символ переноса строки является символом прерывания всех условий.

polishCalc_V2_wStruct
Что нужно добавить в структуру?
- букву переменной
- массив символьных цифр

как поменять свитч в майне, чтобы он принимал данные из структуры?
Может для присваивания значения переменной нужна отдельная функция??
Как гетоп должен понимать, что сейчас идёт присваивание??


calloc.c ========================================================================================
Макс говорит, для решения задачи нужны два массива указателей - одномерный и двумерный.
Наверно, в одномерный я буду записывать строки с переменной block. Зачем их потом записывать в двумерный, пока не очень ясно. Понимание этого придёт, видимо, в моменте реализации динамической памяти для массивов...
Например, у меня уже есть реализация динамического увеличения памяти для одномерного массива...
Ааа, одномерный массив - это строки! А двумерный нужен для хранения нескольких строк! Понятно!)) Да, проверил, всё именно так.
Сейчас попробую сделать реализацию пошаговой записи строк в двумерный массив.
Потом будет сложность разобраться, как откалибровать все строки под одну ширину.


bigDigitCharSum.c ===============================================================================
Чтобы плюсовать символьные массивы чисел, нужно разбивать массив на несколько подмассивов.
Сначала написать цикл FOR по длине массива, внтури него цикл WHILE считает каждые пять, например, чисел. Переводит каждый индекс в целочисленный, плюсует, второй регистр сохраняет в отдельную целочисленную переменную, первый переводит обратно в CHAR.

bigDigitCharSum.c
Попробуй два вводимых числа сохранять в двумерный динамический массив. Вводи их какбы наоборот, а потом разворачивай, и добавляй в начало нули. Полученные числа суммируй, и в итоговом выводе удаляй лишние нули... Невариант

План:
- инициализирую переменные и динамический двумерный массив
- циклом While гетчарю сначала в первый массив, потом во второй. Переключение между массивами происходит по символу переноса строки. Тут же в цикле реаллоцирую массив по необходимости.
- нужно понять каким образом складывать загетчаренные числа. Чую нужно выявлять самый длинный массив и его длину положить в int переменную. Нужно у массива что покороче обрезать переменную i в цикле for: вычесть из длинны длиннющего массива длину массива покороче, сохранить величину в int переменную, и вставить её в суммирующий цикл for.


1000 1000
***1 1***
так нахуй, глядя на эти цифры, есть ощущение, что рождается идея. Нужно у массива что покороче обрезать переменную i в цикле for. Вычесть из длинны длиннющего массива длину массива покороче, сохранить величину в int переменную, и вставить её в суммирующий цикл for.
Заебись, одну проблему решили. Теперь бы понять, куда деть остаток после суммирования больших чисел. Оказывается что похуй на этот остаток, там чисто 1+ регистр. Такс, но с ним тоже может быть дрочево. Я сделаю так - этот регистр сохраню в переменную, и перенесу его в следующий блок цисел... Ан нет, плохо, могу увеличить значение выше 20, а мой перенос остатка отрабатывает на 18 (9 + 9)...

Кароче!!! Остаток от двух здоровых чисел не будет больше "единицы"!!!! Так что па ху ю

fibo_100charSum.c
нужно складывать чарные числа в цикле for().

firstBinarySearchTree.c
Чтобы красиво печатать дерево горизонтально, нужно...

httpStatusCode_quiz_v2.c
Если не использовать внешние переменные, то по хорошему нужно передавать в функцию только ответ. И в main(), в свитче, объявлять две функции. Одна собирает чары в массив, вторая проверяет правильность ответа, и предлагает ответить ещё раз.